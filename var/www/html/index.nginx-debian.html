<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Farmer's Map</title>
        <link rel="stylesheet" href="styles.css">
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
        <style>
            .legend {
                padding: 6px 8px;
                font: 14px/16px Arial, Helvetica, sans-serif;
                background: white;
                background: rgba(255,255,255,0.8);
                box-shadow: 0 0 15px rgba(0,0,0,0.2);
                border-radius: 5px;
                line-height: 18px;
                color: #555;
                max-height: 250px; /* For longer legends */
                overflow-y: auto;   /* For scrollable legends */
            }
            .legend i {
                width: 18px;
                height: 18px;
                float: left;
                margin-right: 8px;
                opacity: 0.7;
            }
            #map {
                height: 600px;
                width: 100%;
            }
        </style>
    </head>
    <body>
        <center><h3 style="color:white;">Crop Recommendation System for Alfonso, Cavite</h3></center>
        <div id="map"></div>

        <div class="temperature-box">
            <p class="main-label">Select a Range of Temperature Data</p>
            <div class="inputs-container">
                <div class="input-wrapper">
                    <label for="curr_date_input" class="input-label">Enter Current Date:</label>
                    <input type="text" id="curr_date_input" name="curr_date_input" placeholder="Enter date">
                    <button id="current_date_btn">SUBMIT CURRENT DATE</button>
                </div>
                <div class="input-wrapper">
                    <label for="alfonso_temp_input" class="input-label">Enter Current Temp in Alfonso:</label>
                    <input type="text" id="alfonso_temp_input" name="alfonso_temp_input" placeholder="Enter temperature">
                    <button id="current_temp_btn">SUBMIT CURRENT TEMP.</button>
                </div>
            </div>
            <div class="dropdowns-container">
                <div class="dropdown-wrapper">
                    <label for="year_dropdown" class="dropdown-top-labell">Pick a Year:</label>
                    <div class="select-wrapper">
                        <select id="year_dropdown" name="year_dropdown">
                            <option value="" disabled selected>PICK A YEAR</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                        </select>
                    </div>
                    <button id="current_yr_month_btn">SUBMIT YEAR & MONTH</button>
                </div>
                <div class="dropdown-wrapper">
                    <label for="month_dropdown" class="dropdown-top-labell">Pick a Month:</label>
                    <div class="select-wrapper">
                        <select id="month_dropdown" name="month_dropdown">
                            <option value="" disabled selected>PICK A MONTH</option>
                            <option value="01">January</option><option value="02">February</option><option value="03">March</option>
                            <option value="04">April</option><option value="05">May</option><option value="06">June</option>
                            <option value="07">July</option><option value="08">August</option><option value="09">September</option>
                            <option value="10">October</option><option value="11">November</option><option value="12">December</option>
                        </select>
                    </div>
                    <button id="temp_clear_btn">CLEAR INPUTS</button>
                </div>
            </div>
        </div>

        <div id="map-types">
            <div id="map-type-selection-btns">
                <p id="body-text">Map Type</p>
                <input type="radio" id="topography" name="map-type" value="topography">
                <label for="topography">Topography</label><br>
                <input type="radio" id="rain" name="map-type" value="rain">
                <label for="rain">Rain</label><br>
                <input type="radio" id="soil" name="map-type" value="soil">
                <label for="soil">Soil</label>
            </div>
        </div>

        <div id="crop-selection">
            <div id="crop-selection-btns">
                <p id="body-text">Crop Selection</p>
                <input type="radio" id = "Chayote" name="crop-selection"><label for="Chayote">Chayote</label><br>
                <input type="radio" id = "Papaya" name="crop-selection"><label for="Papaya">Papaya</label><br>
                <input type="radio" id = "Cucumber" name="crop-selection"><label for="Cucumber">Cucumber</label><br>
                <input type="radio" id = "Eggplant" name="crop-selection"><label for="Eggplant">Eggplant</label><br>
                <input type="radio" id = "Chili" name="crop-selection"><label for="Chili">Chili</label>
            </div>
          </div>

        <script src="temperature-buttons.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', function () {
                var map = L.map('map'); // Initialize map first, setView later
                map.zoomControl.setPosition('topright');

                var osmTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // --- Global variables for layers that might be referenced later ---
                var alfonsoBorderLayer;
                var maskLayer;
                let activeOverlayLayers = [];
                let activeLegend;

                // --- Path to Alfonso Boundary GeoJSON ---
                // Assuming index.html is in /var/www/html/ and geojsons is in /var/www/geojsons/
                // The path should be relative to index.html
                const alfonsoBoundaryPath = 'geojsons/Alfonso/alfonso_boundary.geojson';

                // Fetch the Alfonso boundary GeoJSON
                fetch(alfonsoBoundaryPath)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status} for ${alfonsoBoundaryPath}`);
                        }
                        return response.json();
                    })
                    .then(alfonsoFeatureData => {
                        // Now that we have alfonsoFeatureData, we can create dependent layers

                        // Validate the fetched GeoJSON structure (simple check)
                        if (alfonsoFeatureData.type !== "Feature" && alfonsoFeatureData.type !== "FeatureCollection") {
                             // If it's a FeatureCollection, we might need to extract the first feature
                             // or ensure your alfonso_boundary.geojson is a single Feature object.
                             // For now, let's assume it's expected to be a single Feature.
                             // If it's a FeatureCollection and you only need the first feature:
                             // if (alfonsoFeatureData.type === "FeatureCollection" && alfonsoFeatureData.features && alfonsoFeatureData.features.length > 0) {
                             //    alfonsoFeatureData = alfonsoFeatureData.features[0]; // Use the first feature
                             // } else {
                                throw new Error('Loaded Alfonso boundary GeoJSON is not a valid Feature or non-empty FeatureCollection.');
                             // }
                        }
                         // If alfonso_boundary.geojson is a FeatureCollection with one feature, extract it:
                        let alfonsoActualFeature = alfonsoFeatureData;
                        if (alfonsoFeatureData.type === "FeatureCollection" && alfonsoFeatureData.features && alfonsoFeatureData.features.length > 0) {
                            alfonsoActualFeature = alfonsoFeatureData.features[0];
                             console.log("Using first feature from FeatureCollection for Alfonso boundary.");
                        } else if (alfonsoFeatureData.type !== "Feature") {
                            throw new Error('Loaded Alfonso boundary GeoJSON is not a valid Feature.');
                        }


                        // 1. Create a GeoJSON layer for Alfonso's BORDER (dotted red lines)
                        alfonsoBorderLayer = L.geoJSON(alfonsoActualFeature, { // Use alfonsoActualFeature
                            style: { color: 'red', weight: 2, opacity: 1, dashArray: '5, 10', fillOpacity: 0 }
                        }).addTo(map);

                        // 2. Create the MASK layer (gray out everything else)
                        var maskGeoJson = { type: "Feature", geometry: { type: "Polygon", coordinates: [ [[-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]] ] }};

                        // Add Alfonso's polygon(s) as holes to the mask
                        if (alfonsoActualFeature.geometry && alfonsoActualFeature.geometry.type === "Polygon" && alfonsoActualFeature.geometry.coordinates.length > 0) {
                            maskGeoJson.geometry.coordinates.push(alfonsoActualFeature.geometry.coordinates[0]);
                        } else if (alfonsoActualFeature.geometry && alfonsoActualFeature.geometry.type === "MultiPolygon") {
                            // Handle MultiPolygon: add each polygon part as a hole
                            alfonsoActualFeature.geometry.coordinates.forEach(polygonCoords => {
                                maskGeoJson.geometry.coordinates.push(polygonCoords[0]); // Add the exterior ring of this part
                            });
                        } else {
                            console.warn("Alfonso feature is not a Polygon or MultiPolygon, or has no coordinates; cannot create mask hole properly.");
                        }

                        maskLayer = L.geoJSON(maskGeoJson, {
                            style: { fillColor: 'gray', fillOpacity: 0.6, stroke: false }
                        }).addTo(map);

                        alfonsoBorderLayer.bringToFront(); // Ensure border is on top of mask

                        // 3. Set map view to fit Alfonso's boundaries
                        if (alfonsoBorderLayer.getBounds().isValid()) {
                            map.fitBounds(alfonsoBorderLayer.getBounds());
                        } else {
                            console.error("Could not calculate bounds for Alfonso. Setting a default view.");
                            map.setView([14.1214, 120.8614], 12); // Approx. Alfonso center
                        }

                        // Initialize other map type functionalities now that the base boundary is loaded
                        initializeMapTypeControls();

                    })
                    .catch(error => {
                        console.error(`Failed to load Alfonso boundary GeoJSON from ${alfonsoBoundaryPath}:`, error);
                        alert(`Critical error: Could not load map boundary for Alfonso. Please check console. Defaulting to wider view.`);
                        map.setView([12.8797, 121.7740], 6); // Default to a wider view of PH on critical error
                    });


                // --- Function to initialize map type controls (called after Alfonso boundary is loaded) ---
                function initializeMapTypeControls() {
                    // --- ELEVATION DATA ---
                    const elevationBands = [
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_1.geojson', color: '#4CAF50', label: '0 - 100 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_2.geojson', color: '#8BC34A', label: '101 - 200 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_3.geojson', color: '#CDDC39', label: '201 - 300 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_4.geojson', color: '#FFEB3B', label: '301 - 400 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_5.geojson', color: '#FFC107', label: '401 - 500 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_6.geojson', color: '#FF9800', label: '501 - 600 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_7.geojson', color: '#F44336', label: '601+ m' }
                    ];

                    const rainfallColors = ['#31a354','#74c476','#a1d99b','#c7e9c0','#ffffcc','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#b10026'];
                    const rainfallBands = [
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_1.geojson', color: rainfallColors[0], label: '0 - 5 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_2.geojson', color: rainfallColors[1], label: '5 - 10 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_3.geojson', color: rainfallColors[2], label: '10 - 15 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_4.geojson', color: rainfallColors[3], label: '15 - 20 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_5.geojson', color: rainfallColors[4], label: '20 - 25 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_6.geojson', color: rainfallColors[5], label: '25 - 30 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_7.geojson', color: rainfallColors[6], label: '30 - 35 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_8.geojson', color: rainfallColors[7], label: '35 - 40 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_9.geojson', color: rainfallColors[8], label: '40 - 45 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_10.geojson', color: rainfallColors[9], label: '45 - 50 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_11.geojson', color: rainfallColors[10], label: '50+ mm' }
                    ];

                    function clearActiveOverlays() {
                    activeOverlayLayers.forEach(layer => {
                        if (map.hasLayer(layer)) map.removeLayer(layer);
                    });
                    activeOverlayLayers = [];

                    if (activeLegend) { // If the activeLegend variable exists
                        map.removeControl(activeLegend); // Leaflet handles it if control wasn't on map
                        activeLegend = null;
                        }
                    }

                    function loadGeoJsonBand(bandInfo) { // Removed layerArray parameter
                        return fetch(bandInfo.file)
                            .then(response => {
                                if (!response.ok) {
                                    console.warn(`Warning: Could not load ${bandInfo.file}. Status: ${response.status}. Band "${bandInfo.label}" will not be displayed.`);
                                    return null;
                                }
                                return response.json();
                            })
                            .then(data => {
                                if (data) {
                                    const geoJsonLayer = L.geoJSON(data, {
                                        style: {
                                            fillColor: bandInfo.color,
                                            weight: 0.2,
                                            opacity: 1,
                                            color: 'grey',
                                            fillOpacity: 0.7
                                        }
                                    });
                                    // Don't push to activeOverlayLayers here, do it in displayOverlayLayers
                                    return geoJsonLayer;
                                }
                                return null;
                            })
                            .catch(error => {
                                console.error(`Error processing or fetching band ${bandInfo.file}:`, error);
                                return null;
                            });
                    }

                    function displayOverlayLayers(bandsData, legendTitle) { // Removed targetLayerArray
                        clearActiveOverlays();

                        const promises = bandsData.map(band => loadGeoJsonBand(band));

                        Promise.all(promises).then((loadedIndividualLayers) => {
                            loadedIndividualLayers.forEach(layer => {
                                if (layer) {
                                    layer.addTo(map);
                                    activeOverlayLayers.push(layer); // Add to global active layers
                                }
                            });

                            if (map.hasLayer(maskLayer)) maskLayer.bringToFront();
                            if (map.hasLayer(alfonsoBorderLayer)) alfonsoBorderLayer.bringToFront();

                            if (!activeLegend) {
                                activeLegend = L.control({position: 'bottomright'});
                                activeLegend.onAdd = function (map) {
                                    var div = L.DomUtil.create('div', 'info legend');
                                    div.innerHTML += `<h4>${legendTitle}</h4>`;
                                    bandsData.forEach(band => {
                                        div.innerHTML +=
                                            '<i style="background:' + band.color + '"></i> ' +
                                            band.label + '<br>';
                                    });
                                    return div;
                                };
                                activeLegend.addTo(map);
                            }
                        }).catch(error => {
                            console.error(`General error attempting to load ${legendTitle} layers:`, error);
                        });
                    }

                    const mapTypeRadios = document.querySelectorAll('input[name="map-type"]');
                    mapTypeRadios.forEach(radio => {
                        radio.addEventListener('change', function() {
                            clearActiveOverlays();
                            if (this.checked) {
                                if (this.value === 'topography') {
                                    displayOverlayLayers(elevationBands, 'Elevation (m)');
                                } else if (this.value === 'rain') {
                                    displayOverlayLayers(rainfallBands, 'Rainfall (mm)');
                                } else if (this.value === 'soil') {
                                    console.log("Soil map selected - implement display logic");
                                }
                            }
                        });
                    });

                    mapTypeRadios.forEach(radio => radio.checked = false);
                    document.querySelectorAll('input[name="crop-selection"]').forEach(radio => radio.checked = false);
                } // End of initializeMapTypeControls
            });
        </script>
    </body>
</html>