<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Farmer's Map</title>
        <link rel="stylesheet" href="styles.css"> <!-- Ensure this path is correct -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
        <style>
            .legend {
                padding: 6px 8px;
                font: 14px/16px Arial, Helvetica, sans-serif;
                background: white;
                background: rgba(255,255,255,0.8);
                box-shadow: 0 0 15px rgba(0,0,0,0.2);
                border-radius: 5px;
                line-height: 18px;
                color: #555;
                max-height: 250px; /* For longer legends */
                overflow-y: auto;   /* For scrollable legends */
            }
            .legend i {
                width: 18px;
                height: 18px;
                float: left;
                margin-right: 8px;
                opacity: 0.7;
            }
            #map {
                height: 600px; /* Or whatever height you prefer */
                width: 100%;
            }
        </style>
    </head>
    <body>
        <center><h3 style="color:white;">Crop Recommendation System for Alfonso, Cavite</h3></center>
        <div id="map"></div>

        <div class="temperature-box">
            <p class="main-label">Select a Range of Temperature Data</p>
            <div class="inputs-container">
                <div class="input-wrapper">
                    <label for="curr_date_input" class="input-label">Enter Current Date:</label>
                    <input type="text" id="curr_date_input" name="curr_date_input" placeholder="Enter date">
                    <button id="current_date_btn">SUBMIT CURRENT DATE</button>
                </div>
                <div class="input-wrapper">
                    <label for="alfonso_temp_input" class="input-label">Enter Current Temp in Alfonso:</label>
                    <input type="text" id="alfonso_temp_input" name="alfonso_temp_input" placeholder="Enter temperature">
                    <button id="current_temp_btn">SUBMIT CURRENT TEMP.</button>
                </div>
            </div>
            <div class="dropdowns-container">
                <div class="dropdown-wrapper">
                    <label for="year_dropdown" class="dropdown-top-labell">Pick a Year:</label>
                    <div class="select-wrapper">
                        <select id="year_dropdown" name="year_dropdown">
                            <option value="" disabled selected>PICK A YEAR</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                        </select>
                    </div>
                    <button id="current_yr_month_btn">SUBMIT YEAR & MONTH</button>
                </div>
                <div class="dropdown-wrapper">
                    <label for="month_dropdown" class="dropdown-top-labell">Pick a Month:</label>
                    <div class="select-wrapper">
                        <select id="month_dropdown" name="month_dropdown">
                            <option value="" disabled selected>PICK A MONTH</option>
                            <option value="01">January</option><option value="02">February</option><option value="03">March</option>
                            <option value="04">April</option><option value="05">May</option><option value="06">June</option>
                            <option value="07">July</option><option value="08">August</option><option value="09">September</option>
                            <option value="10">October</option><option value="11">November</option><option value="12">December</option>
                        </select>
                    </div>
                    <button id="temp_clear_btn">CLEAR INPUTS</button>
                </div>
            </div>
        </div>

        <div id="map-types">
            <div id="map-type-selection-btns">
                <p id="body-text">Map Type</p>
                <input type="radio" id="topography" name="map-type" value="topography">
                <label for="topography">Topography</label><br>
                <input type="radio" id="rain" name="map-type" value="rain">
                <label for="rain">Rain</label><br>
                <input type="radio" id="soil" name="map-type" value="soil"> <!-- Added value attribute -->
                <label for="soil">Soil</label><br>
                <input type="radio" id="temperature" name="map-type" value="temperature"> <!-- Added value attribute -->
                <label for="temperature">Temperature</label>
            </div>
        </div>

        <div id="crop-selection">
            <div id="crop-selection-btns">
                <p id="body-text">Crop Selection</p>
                <input type="radio" id = "Chayote" name="crop-selection"><label for="Chayote">Chayote</label><br>
                <input type="radio" id = "Papaya" name="crop-selection"><label for="Papaya">Papaya</label><br>
                <input type="radio" id = "Cucumber" name="crop-selection"><label for="Cucumber">Cucumber</label><br>
                <input type="radio" id = "Eggplant" name="crop-selection"><label for="Eggplant">Eggplant</label><br>
                <input type="radio" id = "Chili" name="crop-selection"><label for="Chili">Chili</label>
            </div>
          </div>

        <script src="temperature-buttons.js"></script> <!-- Ensure this path is correct -->
        <script>
            document.addEventListener('DOMContentLoaded', function () {
                var map = L.map('map');
                map.zoomControl.setPosition('topright');

                var osmTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                var alfonsoBorderLayer;
                var maskLayer;
                let activeOverlayLayers = [];
                let activeLegend;

                const alfonsoBoundaryPath = 'geojsons/Alfonso/alfonso_boundary.geojson';

                fetch(alfonsoBoundaryPath)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status} for ${alfonsoBoundaryPath}`);
                        }
                        return response.json();
                    })
                    .then(alfonsoFeatureData => {
                        let alfonsoActualFeature = alfonsoFeatureData;
                        if (alfonsoFeatureData.type === "FeatureCollection" && alfonsoFeatureData.features && alfonsoFeatureData.features.length > 0) {
                            alfonsoActualFeature = alfonsoFeatureData.features[0];
                             console.log("Using first feature from FeatureCollection for Alfonso boundary.");
                        } else if (alfonsoFeatureData.type !== "Feature") {
                            throw new Error('Loaded Alfonso boundary GeoJSON is not a valid Feature.');
                        }

                        alfonsoBorderLayer = L.geoJSON(alfonsoActualFeature, {
                            style: { color: 'red', weight: 2, opacity: 1, dashArray: '5, 10', fillOpacity: 0 }
                        }).addTo(map);

                        var maskGeoJson = { type: "Feature", geometry: { type: "Polygon", coordinates: [ [[-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]] ] }};
                        if (alfonsoActualFeature.geometry && alfonsoActualFeature.geometry.type === "Polygon" && alfonsoActualFeature.geometry.coordinates.length > 0) {
                            maskGeoJson.geometry.coordinates.push(alfonsoActualFeature.geometry.coordinates[0]);
                        } else if (alfonsoActualFeature.geometry && alfonsoActualFeature.geometry.type === "MultiPolygon") {
                            alfonsoActualFeature.geometry.coordinates.forEach(polygonCoords => {
                                maskGeoJson.geometry.coordinates.push(polygonCoords[0]);
                            });
                        } else {
                            console.warn("Alfonso feature is not a Polygon or MultiPolygon, or has no coordinates; cannot create mask hole properly.");
                        }
                        maskLayer = L.geoJSON(maskGeoJson, {
                            style: { fillColor: 'gray', fillOpacity: 0.6, stroke: false }
                        }).addTo(map);
                        alfonsoBorderLayer.bringToFront();

                        if (alfonsoBorderLayer.getBounds().isValid()) {
                            map.fitBounds(alfonsoBorderLayer.getBounds());
                        } else {
                            console.error("Could not calculate bounds for Alfonso. Setting a default view.");
                            map.setView([14.1214, 120.8614], 12);
                        }
                        initializeMapTypeControls();
                    })
                    .catch(error => {
                        console.error(`Failed to load Alfonso boundary GeoJSON from ${alfonsoBoundaryPath}:`, error);
                        alert(`Critical error: Could not load map boundary for Alfonso. Please check console. Defaulting to wider view.`);
                        map.setView([12.8797, 121.7740], 6);
                    });


                function initializeMapTypeControls() {
                    // --- ELEVATION DATA ---
                    const elevationBands = [
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_1.geojson', color: '#4CAF50', label: '0 - 100 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_2.geojson', color: '#8BC34A', label: '101 - 200 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_3.geojson', color: '#CDDC39', label: '201 - 300 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_4.geojson', color: '#FFEB3B', label: '301 - 400 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_5.geojson', color: '#FFC107', label: '401 - 500 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_6.geojson', color: '#FF9800', label: '501 - 600 m' },
                        { file: 'geojsons/Topo_Layer/ELEV_BAND_7.geojson', color: '#F44336', label: '601+ m' }
                    ];

                    // --- RAINFALL DATA ---
                    const rainfallColors = ['#31a354','#74c476','#a1d99b','#c7e9c0','#ffffcc','#fed976','#feb24c','#fd8d3c','#fc4e2a','#e31a1c','#b10026'];
                    const rainfallBands = [
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_1.geojson', color: rainfallColors[0], label: '0 - 5 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_2.geojson', color: rainfallColors[1], label: '5 - 10 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_3.geojson', color: rainfallColors[2], label: '10 - 15 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_4.geojson', color: rainfallColors[3], label: '15 - 20 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_5.geojson', color: rainfallColors[4], label: '20 - 25 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_6.geojson', color: rainfallColors[5], label: '25 - 30 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_7.geojson', color: rainfallColors[6], label: '30 - 35 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_8.geojson', color: rainfallColors[7], label: '35 - 40 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_9.geojson', color: rainfallColors[8], label: '40 - 45 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_10.geojson', color: rainfallColors[9], label: '45 - 50 mm' },
                        { file: 'geojsons/Rain_Layer/RAIN_BAND_11.geojson', color: rainfallColors[10], label: '50+ mm' }
                    ];

                    // --- MAX TEMPERATURE DATA ---
                    const maxTempColors = [
                        '#4CAF50', // Green (Cooler)
                        '#CDDC39', // Lime
                        '#FFEB3B', // Yellow
                        '#FF9800', // Orange
                        '#F44336'  // Red (Warmer)
                    ];
                    const maxTempBands = [
                        // ENSURE these filenames exist in geojsons/Max_Temp_Layers/
                        // And that Max_temp_1.json corresponds to the coolest band, Max_temp_5 to the hottest.
                        // Update the labels to be meaningful.
                        { file: 'geojsons/Max_Temp_Layers/Max_temp_1.geojson', color: maxTempColors[0], label: '28-28.5°C' },
                        { file: 'geojsons/Max_Temp_Layers/Max_temp_2.geojson', color: maxTempColors[1], label: '28.5-29°C' },
                        { file: 'geojsons/Max_Temp_Layers/Max_temp_3.geojson', color: maxTempColors[2], label: '29-29.5°C' },
                        { file: 'geojsons/Max_Temp_Layers/Max_temp_4.geojson', color: maxTempColors[3], label: '29.5-30°C' },
                        { file: 'geojsons/Max_Temp_Layers/Max_temp_5.geojson', color: maxTempColors[4], label: '>30°C' }
                    ];


                    function clearActiveOverlays() {
                        activeOverlayLayers.forEach(layer => {
                            if (map.hasLayer(layer)) map.removeLayer(layer);
                        });
                        activeOverlayLayers = [];
                        if (activeLegend) {
                            map.removeControl(activeLegend);
                            activeLegend = null;
                        }
                    }

                    function loadGeoJsonBand(bandInfo) {
                        return fetch(bandInfo.file)
                            .then(response => {
                                if (!response.ok) {
                                    console.warn(`Warning: Could not load ${bandInfo.file}. Status: ${response.status}. Band "${bandInfo.label}" will not be displayed.`);
                                    return null;
                                }
                                return response.json();
                            })
                            .then(data => {
                                if (data) {
                                    return L.geoJSON(data, {
                                        style: {
                                            fillColor: bandInfo.color,
                                            weight: 0.2, opacity: 1, color: 'grey', fillOpacity: 0.7
                                        }
                                    });
                                }
                                return null;
                            })
                            .catch(error => {
                                console.error(`Error processing or fetching band ${bandInfo.file}:`, error);
                                return null;
                            });
                    }

                    function displayOverlayLayers(bandsData, legendTitle) {
                        clearActiveOverlays();
                        const promises = bandsData.map(band => loadGeoJsonBand(band));

                        Promise.all(promises).then((loadedIndividualLayers) => {
                            loadedIndividualLayers.forEach(layer => {
                                if (layer) {
                                    layer.addTo(map);
                                    activeOverlayLayers.push(layer);
                                }
                            });

                            if (map.hasLayer(maskLayer)) maskLayer.bringToFront();
                            if (map.hasLayer(alfonsoBorderLayer)) alfonsoBorderLayer.bringToFront();

                            if (!activeLegend && bandsData.length > 0) {
                                activeLegend = L.control({position: 'bottomright'});
                                activeLegend.onAdd = function (map) {
                                    var div = L.DomUtil.create('div', 'info legend');
                                    div.innerHTML += `<h4>${legendTitle}</h4>`;
                                    bandsData.forEach(band => {
                                        div.innerHTML +=
                                            '<i style="background:' + band.color + '"></i> ' +
                                            band.label + '<br>';
                                    });
                                    return div;
                                };
                                activeLegend.addTo(map);
                            }
                        }).catch(error => {
                            console.error(`General error attempting to load ${legendTitle} layers:`, error);
                        });
                    }

                    const mapTypeRadios = document.querySelectorAll('input[name="map-type"]');
                    mapTypeRadios.forEach(radio => {
                        radio.addEventListener('change', function() {
                            clearActiveOverlays(); // Clear previous overlays first
                            if (this.checked) {
                                // Ensure a value attribute is set on your radio buttons in HTML
                                if (this.value === 'topography') {
                                    displayOverlayLayers(elevationBands, 'Elevation (m)');
                                } else if (this.value === 'rain') {
                                    displayOverlayLayers(rainfallBands, 'Rainfall (mm)');
                                } else if (this.value === 'temperature') {
                                    displayOverlayLayers(maxTempBands, 'Max Temperature');
                                } else if (this.value === 'soil') {
                                    console.log("Soil map selected - implement display logic");
                                    // displayOverlayLayers(soilBands, 'Soil Type'); // Example for future soil layers
                                }
                            }
                        });
                    });

                    // Initialize radio buttons to unchecked state
                    mapTypeRadios.forEach(radio => radio.checked = false);
                    document.querySelectorAll('input[name="crop-selection"]').forEach(radio => radio.checked = false);

                } // End of initializeMapTypeControls
            });
        </script>
    </body>
</html>